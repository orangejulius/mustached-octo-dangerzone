Problem 1:
Assume you have all the share prices of a stock for the year in an array. The order of prices in this array is chronological; so the first price in the array represents the oldest price from 2011 and the last price in the array represents the most recent price from 2011. Given this data, how would you determine what could've been the best transaction you could've made in 2011. A transaction is just a buy of one share, then a sell of that share (no shorts, etc.), and best transaction implies the most profit you can make out of such a transaction (ignore holding time and tax implications).

Problem 2:
Say you have an array that is already sorted in non-descending order. e.g. [3, 4, 5, 5, 6] (Note that duplicates are allowed). Then someone comes along and rotates this array to the right, e.g. rotating this array to the right by 1 position would make it [6, 3, 4, 5, 5]. Now, you are given only this rotated array (not the original sorted array). How would you determine how many places to the right the original array was rotated. There is a trivial O(n) solution to this problem, but I'm interested in the most efficient solution that is able to handle duplicates.
